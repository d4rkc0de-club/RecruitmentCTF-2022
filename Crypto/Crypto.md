# Crypto
## baby_encryption
### Category
Crypto
### Points
38
### Challenge Description
One of the 60-character strings in this file has been encrypted by single-character XOR. Find it.
### Attached Files
[q.txt](q.txt)
### Explanation
We see that 1.txt is a file written in hexadecimal charachters `(0-9, a-f)`. We're griven in the challenge description that one of the strings in this file has been XORed with a single charachter.

![This image shows the hex charachters present in the q.txt file](Images/baby_encryption1.png "q.txt")

- XOR: A binary operation that takes two strings, converts them to binary, and for each corrosponding digit pair, returns 0 if both digits are 0 or 1, and returns 1 if one of the digits is 0 and the other is 1.
### Exploitation
We're supposed to brute force all of the strings with all the possible charachters in ASCII (There are 256 of them, by the way). This can be done by XORing the given strings with each charachter again (Why? Search up "Properties of XOR" on Google). Since there are multiple strings and only one of them is our flag, we won't be reading all of them. Instead, we can write a script in python to perform this brute force and return the string which has `d4rkc0de` in it.
### Exploitation Script
[baby_encryption_sol.py](baby_encryption_sol.py)
### Flag
`d4rkc0de{3ncrypt10n_!=_x0r}`

## Encryption_101
### Category
Crypto
### Points
92
### Challenge Description
Once there were 3 friends, each of them represent a number in the txt file.
### Attached files
[encrypt.py](encrypt.py), [encrypted-messages.txt](encrypted-messages.txt)
### Explanation
`encrypted-messages.txt` has 12 blocks of numbers, each with three numbers: `n`, `e`, `c`. Interestingly enough, all the `e`'s are 3. If you search `"n, e and c in cryptography"` on Google, you'll soon realise that this challenge is using the **RSA Cipher**.

---

***Note: RSA***

RSA (Rivest–Shamir–Adleman) is a public-key cryptosystem that is widely used for secure data transmission. In the most basic terms, it works by taking a message, `m`, converting it into bytes and then into an integer, then raising it to the power of the number `e` and taking the modulo `n` of the entire result, where n is a number generated by multiplying two random, large primes. 

This was thought to be secure because it is difficult to factorise large numbers, however, some common misconfiguraations make it prone to attacks.

---

Now, let's try to understand the python script

```python
with open('flag.txt', 'rb') as f:
    flag = f.read()

msgs = [
    b'Never gonna give you up!',
    b'Never gonna let you down!',
    b'Never gonna run around and desert you!'
        ]

e = 3
msgs.append(flag)
msgs *= e
random.shuffle(msgs)
```

This part of the code reads the flag, and adds it to a list of messages (get rickrolled xD), and then these messages are written in the list three times and shuffled

```python
for msg in msgs:
    n = getPrime(1024) * getPrime(1024)
    m = int.from_bytes(msg, 'big')
    c = pow(m, 3, n)
    with open('encrypted-messages.txt', 'a') as f:
        f.write(f'n: {n}\n')
        f.write(f'e: {e}\n')
        f.write(f'c: {c}\n\n')
```

Now, this is the part where the RSA cipher is applied. The `pow(m,3,n)` function is taking `m` to power `3` and taking the modulo by `n`. As it matches from our observation in `encrypted-messages.txt`, `e = 3` for each message.

### Exploitation
The only pattern we keep observing here is that `e = 3`. Searching `"RSA Attacks with e = 3"` on Google leads us to [this blog post](https://www.johndcook.com/blog/2019/03/06/rsa-exponent-3/) by John D. Cook. This matches our interest because for such an attack, we need three different cipher texts for each message, and because the python program generated three messages of the same type, we have them!

However, we don't know which ciphertext corrosponds to which message, because they were randomly shuffled. At this point, it is a good idea to take a look at `encrypted-message.txt` again. We observe that a particular set of ciphertexts, `c`, are being repeated over and over again! This means this RSA configuration is even more flawed as the `c < n` for each n. This makes it very easy to find out the flag.

Our methodology will be to take the `x = ci mod ni` for each cipher text we have, and then find out the `x^(1/3)` and convert it back into `bytes` from `int`. However, we can skip the first step as `c < n`.

You can search about converting int back to bytes and you'll get a lot of answers on Stack Overflow on how to do that.

One problem I faced was that the inbuilt functions or the math module in python weren't good enough to find out the cuberoot of large numbers like `c`. Searching `"How to find cuberoots of large numbers in Python"` on Google led me to [this blog](https://riptutorial.com/python/example/8751/computing-large-integer-roots) on RIP Tutorial which helped me a lot
### Exploitation Script
[encryption_101_sol.py](encryption_101_sol.py)
### Flag
`d4rkc0de{cr4ck1ng_RSA_101}`

## break_it
- Category : Crypto
- Points : 100
- Chellenge Description: Can you break this encyption standard? `nc ctf.d4rkc0de.iiitd.edu.in 20003`
- Attached files: [chall3.py](chall3.py)
